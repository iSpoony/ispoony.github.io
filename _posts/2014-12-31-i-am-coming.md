---
layout:     post
title:      开始于2014结束之时
date:       2014-12-31 17:12:00
summary:    Life should be storable.
categories:
---

在2014年即将结束的时候，我终于恍悟，人生一场，若不留痕迹就好像没有记忆。

正式工作已经快两年，踩坑无数，却只顾埋头填坑，没有总结经验教训就急冲冲去踩下一个坑。现在回想，觉得挺遗憾的，为了以后不为现在遗憾，就从现在开始改变吧。

理一下流水账先。（以情绪为主）

刚进入工作时，接手代码发布系统。原系统是用Python开发的，将svn、git托管的代码提取出来，通过rsync的方式同步到目标服务器上。中间还整合了令人无语的“排除列表”，就是说每个代码仓库里面指定了一些文件不要同步。总之感觉代码上线这件事情特别不规范。当然，在后面我接手这件事情的时候也深有体会，开发同学、运维同学甚至测试同学会提出各种各样的“特殊情况”，增加各种各样的功能，整个事情缺乏系统性、规范性，很难做得漂亮。

当时带我做这个项目的同事打算用RPM打包、安装的方式传送代码文件，于是让我研究RPM打包机制。那时我对Linux还很陌生，CentOS更是不熟。满世界查资料的时候发觉这是人们十多年前就在讨论的技术了，觉得特别受挫。自己去尝试的过程总是不顺利，除此之外还有很多新东西要学习、适应。那可真是噩梦般的经历，在我刚开始工作的一个半月。一个多月的时间，这个项目进展缓慢，老大很不高兴。正好那会儿豆瓣在推Code，于是老大带我们去豆瓣学习了一下他们的经验。回来之后我们决定采用Gitlab来托管代码，代码发布也采用Git本身的特性进行。

当时Gitlab的版本是5.3，我对照着安装文档花了大约半天时间才在本机（Ubuntu环境）搭建成功。老大申请了一台服务器（CentOS环境）来搭建正式服务。当时遇到的问题大多是Ruby、Rails环境，以及Gitlab对CentOS环境的不支持等等，虽然不明所以，但最后还是跑起来了，于是我开始对Gitlab的代码二次开发，增加发布的功能。

我从来没有接触过Ruby，也从来没听说过认识的谁用Ruby开发，所以是完全陌生的一门语言，但还是要硬着头皮上。好在照葫芦画瓢是一种能快速见效的事情。每天都有新收获，每天都能看到新成果，感觉还是很美的。很快就到了转正的日子，端午前的最后一个工作日，部门主管找我谈话，说到了前一段时间一直没有成果，主要问题不在我，好在现在已经进入正轨了，继续努力巴拉巴拉，大概是这样。那天之前下了好几次大雨，那天谈完话出来就看到天空放晴，西方一片金色，东方挂着一座大大的彩虹，心情甚是美丽。那天还因端午放假提前下班，我还是过了好久才回去。印象中，前两个月几乎没有晚上十一点之前下过班。在之后的时间，晚上从公司出来打不到车更是家常便饭，直到后来有了打车软件，再后来打车软件也打不到车，再再后来我搬到公司附近住了，幸福感蹭蹭往上蹿。扯远了，这都是后话。

在我开发的过程中，老大开始找各个组的老大过来演示，希望推广大家改用Git方式来协作。等到发布功能跑通，老大组织了一次会议，向大家介绍新的代码托管&发布系统。从那之后，开发之外的另一项工作就是催促各个组的项目迁移，这是一项长期的工作，由于有些项目严重依赖“排除列表”，比较排斥新的工作方式，几乎到了年底才迁移完毕。

至此，代码发布系统的工作方式是：开发同学创建项目、自行管理代码；运维同学从管理员页添加主机信息（主机名、IP、SSH Key）、关联项目和主机的对应关系、部署项目代码到目标主机；开发同学在项目发布页选择分支（Commit ID）和主机，然后发布代码。发布代码的过程依赖消息队列来进行，发布系统的每个发布操作都是往消息队列里面写一条消息，每台主机上运行一个Agent，来接收消息队列里的消息，并执行相应的操作。运维同学是我的大甲方，他们总是吐槽系统中为他们的工作带来阻碍的地方：不能批量添加机器、主机不能批量关联项目、批量部署Agent很麻烦等等。开始的时候Agent是另一位同事用Python写的，为了应对运维的各种不满也是改了无数次。后来测试组上线了配置管理系统，发布系统也配合增加了配置文件的发布，于是我接过Agent添加了获取配置文件的功能。

当时的痛点在于：每台主机的SSH Key要手工生成，再添加至发布系统，随着主机数量的增多，批量操作很不方便；早期版本的Agent部署时有一些交互，需要手动输入一些参数，调整之后还是有些错误处理不是很完善，因为代码不是我写的，具体我也记不清楚了。

在各方压力下，这个发布系统被我做得奇形怪状的，有谁需要什么功能我就改，不方便改就新增。到最后一个项目发布到不同机器上可以设置不同的目录，一个项目可以设置发布到每个环境（测试、预上线、正式）的默认目录，项目发布时可以支持代码更新前后执行一段命令，可以针对不同的主机设置执行不同的命令，可以为主机进行分组管理，可以对该组批量关联项目，同时还支持主机单独与项目关联等等。这需求已然让我无语，代码也让我不忍直视，系统运行效率也很低，自己都觉得写的是垃圾。

除了日常开发维护，我还充当着帮同事解决Git问题的角色，经常有人来问SSH Key、合并、回滚等等问题。次数多了我就很无语，好歹是技术人员，明明可以自己搜索解决的问题还要来问别人，严重影响别人的工作。此外还有Gitlab的使用问题，由于未知原因（猜测受我改动影响或者是Gitlab本身对CentOS系统不兼容），Gitlab提供的一些功能出现异常，如MergeRequest不能自动合并、Satellite不能自动创建，我也要在服务器上手动执行脚本来解决。这些事情很小很琐碎也很耽误时间。

快到年底的时候，我们组有项目开始使用Golang。我也凑了热闹，简单学了些语法，了解了语言特性，计划把Agent用Go重写，梳理了功能点便开始开发。用Go开发的过程真是痛快，用一个词来形容的话就是酣畅淋漓。

还是年底的时候，代码发布有新的需求，由于年后海外业务要上线，发布系统要支持发布至海外服务器。当时跟运维同学讨论完需求后，老大说海外发布用RPM打包安装的方式进行，我脑子里嗡的一下子蒙了，怎么又扯上RPM了，走了这大半年一夜回到解放前吗！没办法只能做。发布系统新增了个页面作为入口，还要有打包服务，打完包还要把包放到海外机房的中转机器，中转机器上还要部署相应的文件服务、消息转发服务。发布流程变得更混乱了，而且中间有差错很难定位。就这样，最后如期上线了，然后就是不断地找问题、修bug。当时还画了结构图，依然是让人不忍直视。

一直到三月份，海外站的发布问题很多。由于代码服务器放在内网，发布至线上服务器由于网络带宽原因会很慢。这种情况下我向运维组提出将代码服务迁至线上服务器，内网保留当做镜像，这样能节省带宽占用，而且还能备份。而且趁这个机会，我申请了线上服务器系统版本采用Ubuntu Server。申请很快被批准，于是开始着手代码仓库的迁移、代码服务的迁移。最终迁移还算顺利，影响比较大的一点是Git Server的IP变了，需要所有的Git Client端修改`known_hosts`。

迁移之后有了空闲的服务器，我把Gitlab CI搭起来了。同时Agent们也在持续重构中，各种调整，写单元测试，跑CI。虽琐碎，但看到绿色的PASS和不断变大的coverage还是很有成就感的。

就在这段时间我忽然开窍了，代码托管和代码发布明明是两种服务，为什么要放在一起呢？而且Gitlab本身提供了那么多的API，我用到的东西直接调用就好了呀。想通之后我脑中很快就有了清晰的轮廓，于是开始筹划重做发布系统。发布系统独立出来有几个主要功能点：用户认证及权限分配、项目获取及设置、项目主机关系管理、代码发布、配置文件发布。在技术选型上，我又走了一点弯路，第一版是用Go写的，当时写Go写得太爽了，觉得用Go写一个Web服务不过如此嘛。后来写着写着感觉逻辑太多了，用Go就是纯手工，写得太慢了，也未必能写得好，于是又重写，第二版用Rails和Mysql。写了一段时间，又发现结构化数据每次改结构都要重新改表结构，我这想法又变来变去的，每次改表结构太麻烦了，于是开始了第三版，也就是现在在役的发布系统。这一版用的Rails和Mongo，以前没玩过Mongo，这回也算尝尝鲜了，结果发现味道还可以。

开始做之前，四月初，我和运维同学们反复确认需求，确定了几项约定：一个项目确定唯一的发布目录和唯一的发布前后的执行脚本；主机及主机分组信息由运维组提供API，发布系统定时更新；项目和主机组进行关联，不再同单独的主机做关联；主机的SSH Key由Agent生成并添加，不再需要人工干预。此外还有一项改动，海外机房的发布回归Git方式，在海外机房创建Git镜像，由代码服务器为项目仓库创建`post-receive`保证同步。镜像服务器上要部署镜像服务，用来添加`authorized_keys`和创建项目仓库。最终涉及的后端服务包括：发布系统端主机同步任务、主机-项目关联检查任务、接收消息的Server Agent，海外机房的镜像代理、消息转发服务，以及各个主机上的Agent。主机端Agent启动时根据主机名判断所属的站点，然后连接至该环境下的Zookeeper服务，获取自己所需的配置信息，包括消息服务地址、代码镜像地址等。吸取了过去一年踩坑的教训，再做起来从容多了。

七月初，新的发布系统终于上线了，Gitlab也顺便做了升级，用了6.3的版本，体验也好很多，以前无解的问题都消失了。每次巨大改动产生的坑都要好一阵子来填。后来又改了一些处理方式，比如SSH Key不是由主机Agent生成，而是由发布系统来生成，Agent启动时获取私钥，并更改机器上的`~/.ssh/config`，指定获取代码时采用的私钥文件。

到了八月初，我的Agent们终于可以让我省点心了，我一度觉得自己可以闲下来做点别的项目了，但最终只是闲下来，没有别的项目让我插手，为此空虚了好长时间。其实这个发布系统还是有很多可以做的。往小了说，这个系统其实用户体验并不太好，页面丑陋，交互机械，也没有延迟加载机制；往大了说，代码发布不应该仅仅是这些，可以接入测试流程、编译或构建流程，再大了还可以接入项目Bug跟踪（说到这我想到了以前在MS实习时接触到的开发流程，可真是一项浩大的工程）。事情想想都很多，可是我心里上已经很抵触了，从项目开始到现在，我一个人负责这全套服务，都不知道和别人协作是什么体验了。而且反复重构，经常自己转着圈想不清楚，也没个人可以讨论。最后做出来其实还是会失落，觉得不就这么个事么，让我花了那么多功夫。往让自己舒服的方向想呢就是：凡事都有个过程，咱脑子不灵活，那咱就勤奋点吧。

接下来的一两个月里，我跟着组里超神做他的小项目Kite、Golang的基础Log库，写UT，打下手。我感受到差距，也为此焦躁。写Go代码的时候我常常想到人生，明明觉得很精彩，到自己手上却很无奈。

九月底，信息部对LDAP服务做了限制，代码发布服务用户登录功能受到影响。此前信息部在推CAS统一认证，我们这边没有被通知到，于是又花了一阵功夫去紧急解决这个事。发布系统还好，自己写的是可控的。Gitlab就麻烦了，由于信息部CAS认证返回的字段缺失，导致Gitlab采用的Gem包认为认证失败，于是我又硬着头皮改了相关的逻辑（之前说好的不改代码不改代码呢，真是无奈）。

十一过后，我又接了个需求，测试组要接入自动化测试了。需求依然很奇葩，因为整个工作方式就是一坨葩。自动化测试不自己关注代码版本号，而是发布系统往测试环境发布完代码之后调接口时传过去，太不严肃了。但还是要做的，讨论达成一致就开工了。于是我又新增了个发布入口页面。。我真对自己无语。。总之逻辑通了，按照约定的那样。我的心态有点不一样了，觉得反正不是我定的，垃圾也不关我事。这么说怎么觉得在自甘堕落。

再后来，老大让我给组里另一个项目做一个工具，用来帮他们自动执行导数据的工作。他们平时都是：A跑完数据发封邮件给大家说数据好了，放在哪台机器哪个目录，然后B拿这个数据去核对一下，完后再发封邮件给大家说数据没问题，然后C拿这份数据跑自己的程序。这个功能直接在已有的一个项目里面新加一个模块做，用Python开发，Web框架是tornado。开发工具不是问题，问题在于需求。我的甲方是C，她给我理了整个流程，还算清晰，但细节很多。我最担心的是做出来的东西很鸡肋，可这似乎always happen..

做完之后，我又开始继续重构我的Agent们了。这次是把跨机房的消息服务集中化管理，同时去掉对Zookeeper的依赖，关键是整个消息分发机制的集中化、服务化。这次改动应该是项目至今最彻底的一次，对最基本的消息分发做了改动。最终批量升级了700+台机器的Agent，一切正常，很是欣慰。

今年最后一个活儿是一个问题征集系统，很简单的表单提交。

好了，我说够了。
